<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="by David Moon and Cyrus Omar" />
  <title>Restructuring Structure Editing</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Restructuring Structure Editing</h1>
<p class="author">by <a href="https://dmoon.fun/">David Moon</a> and <a href="https://web.eecs.umich.edu/~comar/">Cyrus Omar</a></p>
<p class="date">October 2021</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#terms-versus-tiles">Terms versus tiles</a></li>
<li><a href="#opseqs-and-holes">Opseqs and holes</a></li>
<li><a href="#inserting-and-removing">Inserting and removing</a></li>
<li><a href="#selecting-and-restructuring">Selecting and restructuring</a></li>
</ul></li>
<li><a href="#related-work">Related Work</a></li>
<li><a href="#ongoing-work">Ongoing Work</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<!-- \label{sec:intro} -->
<p><em>Structure editors</em> have long promised to improve the programming experience for beginners and experts alike. By eliminating parse errors, they provide cognitive benefits for novices <span class="citation" data-cites="meta-analysis-blocks blocks-text-high-school coblox">[10, 29, 30]</span> and end-users <span class="citation" data-cites="weitnauer2016graspable rousillon BasHermans21">[5, 11, 31]</span>; simplify language composition <span class="citation" data-cites="mbeddr">[25]</span> and language-aware editor tooling <span class="citation" data-cites="HazelnutSNAPL">[21]</span>; and form an essential component of truly continuous live programming <span class="citation" data-cites="Hazelnut HazelnutLive">[19, 20]</span>. Yet, in the forty years since the idea was first introduced and implemented <span class="citation" data-cites="Cornell">[22]</span>, structure editing has failed to reach mainstream use by programmers beyond the novice level. The problem, as many have observed <span class="citation" data-cites="user-modeling fine-tuning-selection-semantics practical-lang-based-editing lang-on-the-usefulness psg Minor92 TowardUserFriendly MillerPMV94">[1, 7, 13, 15, 16, 18, 23, 26]</span>, is that structure editors can be too slow or difficult to use.</p>
<p>For example, while block-based editors like Scratch <span class="citation" data-cites="scratch">[14]</span> excel at introducing programming to children and end-users, they soon become unwieldy as users gain experience and create larger programs. Cited issues include their inefficient mouse-driven input, low visual information density, and rigid tree-based construction of operator sequences <span class="citation" data-cites="BlocksFingertips cog-dim-blocks blocks-and-beyond">[2, 9, 17]</span>.</p>
<p>Other structure editors like JetBrains MPS <span class="citation" data-cites="DBLP:conf/icse/VoelterP12">[27]</span> resolve those particular issues with keyboard-driven text-like interfaces, but instead suffer from steep learning curves and difficult-to-predict editing behavior. Consider the violin plots below, adapted from <span class="citation" data-cites="ProjEfficiency">[3]</span>, <!-- \ref{fig:mps-violin-plots}, --> that show post-task questionnaire responses gathered in a controlled user study of MPS. Each plot partitions the user responses by study groups: novice MPS users (Proj), expert MPS users (ProjE), and text editor users (Par). The left two plots show that MPS novices felt that selection was relatively slow and inaccurate despite a 45-minute training session and another 30-45 minutes worth of study tasks. Meanwhile, the right two plots show that MPS novices and <em>experts</em> alike struggled to predict the effects of deletion.</p>
<p><img src="img/mps-violin-plots.png" /></p>
<p>Whether they are mouse-driven and block-based, or keyboard-driven and text-like, structure editors as a whole have suffered from high viscosity <span class="citation" data-cites="cog-dim">[8]</span>, i.e., it is difficult to modify and restructure existing code. We believe this is a fundamental consequence of the basic assumption that structure editors should operate directly on the abstract syntactic structure of a program. <!-- \footnote{\note{add comment here clarifying
this is talking about pure structure editors and not
hybrid ones and forward reference to related work}} --> This assumption restricts selections to complete program terms, a severe limitation compared to the arbitrary range selections of text editors. <!-- \note{come back if there's time and talk a bit about
Amy's thing and weave in a little more text editor vs
structure editor dichotomy earlier} --></p>
<p>In this essay, we describe a new approach to structure editing, called <em>tile-based editing</em>, that recovers many of the flexible and linear editing affordances of text editors. The key insight is that, in order to guarantee edit state well-formedness, it is sufficient to maintain a structure more relaxed than the abstract syntactic structure demands, but on which parsing is guaranteed to succeed.</p>
<p>Using a tile-based editor, the user manipulates structural components called <em>tiles</em> that are shaped to fit together according to their syntactic roles, <em>à la</em> blocks in a block-based editor. Unlike blocks, tiles directly model linear operator sequences and facilitate left-to-right editing using keyboard input.</p>
<!-- have a figure just to give initial taste -->
<p>Uniquely, tiles may be broken apart into <em>shards</em> as needed to specify arbitrary range selections up to token boundaries. Using a novel <em>restructuring mode</em>, the user may then “cut and paste” these selections like in a text editor. Unlike text-based cut-and-paste, however, restructuring mode ensures you paste your selections such that the result is a well-formed program term.</p>
<!-- show an example of shard selection + restructuring -->
<!-- bullet point maintaining tile structure + hole fixing -->
<h1 id="overview">Overview</h1>
<p>We now present an example-driven overview of tile-based editing using <code>tylr</code>, a tiny tile-based editor. Interested readers may follow along on a running instance of <code>tylr</code> at <a href="https://tylr.fun">tylr.fun</a>.</p>
<p>Say we are using <code>tylr</code> to edit a function that gets called by a generative drawing application <span class="citation" data-cites="sns-pldi">[6]</span>. The function takes an integer index and returns a circle—represented as a pair comprising its center point and radius—to be drawn in the <span class="math inline"><em>x</em><em>y</em></span>-plane for every index. The initial program draws unit circles along the line <span class="math inline"><em>y</em> = <em>x</em></span>, as shown below.</p>
<p><img src="img/circles-n-n-1.png" width="175" /> <img src="img/init-program.png" width="350" /></p>
<h2 id="terms-versus-tiles">Terms versus tiles</h2>
<p>Panning the cursor over the program in <code>tylr</code> reveals the program structure as governed by <code>tylr</code>’s <em>term syntax</em>, the relevant subset of which is included below.</p>
<p><video src="mov/pan-term.mov" width="300" controls=""><a href="mov/pan-term.mov">Video</a></video> <img src="img/term-syntax.png" width="350" /></p>
<p>For example, the first edit state seen in the video shows the top-level function—an expression term as indicated by the green coloring—binding the pattern variable  and returning an indexed circle. Notice how every term has a convex hexagonal shape.</p>
<p>Highlighted within each term is a substructure called a <em>tile</em>; with respect to the containing term, we say it is the term’s <em>root tile</em>. Each term’s root tile encompasses all root-level tokens used to represent the term, along with children of the term that the tokens delimit on both sides—such children we call <em>bidelimited</em>. For example, in the first edit state of the video above, observe how the function’s highlighted tile spans the function’s tokens <span class="math inline"><strong>λ</strong></span> and <span class="math inline"><strong>.</strong></span> as well as the bidelimited pattern child; however, it does not extend to the <em>unidelimited</em> body child.</p>
<p>Holding Alt/Option while panning the cursor reveals the program structure as governed by <code>tylr</code>’s <em>tile syntax</em>, shown below.</p>
<p><video src="mov/pan-tiles.mov" width="300" controls=""><a href="mov/pan-tiles.mov">Video</a></video> <img src="img/tile-syntax.png" width="400" /></p>
<p>Tiles enjoy a flatter structure compared to the strictly hierarchical terms. Notice in the first edit state seen in the video, for example, how the tiles comprising the function body are siblings with the function term’s root tile. The <em>tips</em> of a tile indicate its syntactic role in the tile sequence as a(n):</p>
<ul>
<li><span class="math inline">⟨</span>operand<span class="math inline">⟩</span>,</li>
<li><span class="math inline">⟨</span>prefix operator<span class="math inline">⟨</span>,</li>
<li><span class="math inline">⟩</span>postfix operator<span class="math inline">⟩</span>, or</li>
<li><span class="math inline">⟩</span>infix operator<span class="math inline">⟨</span>.</li>
</ul>
<p>Where traditional structure editors model their edit states using the strictly hierarchical term syntax, <code>tylr</code> instead models its edit state using the flatter tile syntax, precedence-parsing the tile structure as needed to produce the term structure. Indeed, the term structure shown in the first video is simply a decoration overlaid atop the actual tile structure shown in the second video. Moving forward, we will refer to structure editors with term-structured edit states as <em>term-based editors</em>.</p>
<h2 id="opseqs-and-holes">Opseqs and holes</h2>
<p>The edit states above are in <em>pointing mode</em>, <code>tylr</code>’s default editing mode. Much like how a text editor’s cursor points at positions between characters in its default mode, <code>tylr</code>’s default cursor points at positions between tiles. <!-- % \note{note how they are explicitly indicated in above
% the terms/tiles, the local cursor positions for the current tile
% sequence are shown, that we can speak meaningfully of the
% sort of a cursor position, maybe forward reference that
% this will be useful for explaining how selecting works} --> <code>tylr</code>’s central guarantee is: if you are in pointing mode, then you can parse the tiles of your edit state into a well-formed program term.</p>
<p>Simply maintaining a well-formed tile structure according to the tile syntax alone, however, is not sufficient to uphold this guarantee. The generic sequential structure of tile sequences simplifies how we define edit operations, but does not guarantee that the tiles represent a well-formed <em>operator sequence</em>, or <em>opseq</em> for short. The qualifications for a tile sequence to be an opseq enjoy a simple physical metaphor:</p>
<ol type="1">
<li>every tile <em>fits</em> its neighbors: if a pair of tips meet, they look like <span class="math inline">⟨⟨</span> or <span class="math inline">⟩⟩</span>; and</li>
<li>the tile sequence is <em>convex</em>: it is nonempty, the first tile’s left tip <span class="math inline">⟨</span> points left, and the last tile’s right tip <span class="math inline">⟩</span> points right.</li>
</ol>
<p>If <code>tylr</code> maintains the opseq structure in pointing mode, then we have our guarantee, since precedence-parsing is total on opseqs.</p>
<p>For this reason, <code>tylr</code> automatically inserts and removes placeholder tiles called <em>holes</em> as we edit to maintain opseq structure. There are two kinds of holes: <em>operand holes</em> <img src="img/ophole.png" style="width:1em" /> and <em>operator holes</em> <img src="img/binhole.png" style="width:1em" />. We will soon see a number of examples of automatic hole fixing as we turn our attention to editing.</p>
<h2 id="inserting-and-removing">Inserting and removing</h2>
<p>By having us edit the tile structure, and only indirectly propagating those changes to the term structure, <code>tylr</code> supports many of the linear editing workflows to which we are accustomed in text editors.</p>
<p><strong>Inserting and removing leaf tiles.</strong> For example, say we update our program to draw circles along the parabola <span class="math inline"><em>y</em> = <em>x</em><sup>2</sup>/9</span>. <img src="img/circles-parabola.png" width="60" /> We can accomplish this simply by typing left-to-right:</p>
<p><video src="mov/parabola.mov" width="350" controls=""><a href="mov/parabola.mov">Video</a></video></p>
<p>If we decided now to draw circles along the reflected parabola <span class="math inline"><em>x</em> = <em>y</em><sup>2</sup>/9</span>, <img src="img/circles-parabola-transpose.png" width="60" /> we could similarly remove the inserted tiles right-to-left from the <span class="math inline"><em>y</em></span>-coordinate and re-insert them in the <span class="math inline"><em>x</em></span>-coordinate.</p>
<p><video src="mov/parabola-2.mov" width="350" controls=""><a href="mov/parabola-2.mov">Video</a></video></p>
<p>These simple editing workflows are not trivial in traditional term-based editors because, from the perspective of the AST, linear construction of operator sequences is a complex, context-sensitive operation. Existing structure editors either embrace strictly tree-based construction of operator sequences <span class="citation" data-cites="scratch">[14]</span>; defer to text at the expression level <span class="citation" data-cites="Cornell greenfoot">[12, 22]</span>, recovering linearity at the cost of structure; or solve the problem at the cost of complexity <span class="citation" data-cites="GrammarCells">[24]</span>. In contrast, tiles combined with automatic hole fixing make it easy to define linear editing operations without compromising structure.</p>
<!-- Tiles enable linear editing of operator sequences,
while continuously maintaining structure and
relying on simple precedence parsing
to update the operator sequence's associative structure
as you type. -->
<p><strong>Inserting and removing non-leaf tiles.</strong> While insertion and removal of leaf tiles closely mimics the text editing experience, this begins to change as we turn our attention to non-leaf tiles. For example, consider how we would remove the parentheses wrapping the origin coordinates in <code>tylr</code>:</p>
<p><video src="mov/delete-paren.mov" width="350" controls=""><a href="mov/delete-paren.mov">Video</a></video></p>
<p>Where a text editor would simply remove the closing parenthesis on the first Backspace, leaving us with a syntax error, <code>tylr</code> first enters an intermediate state in which it has “picked up” the closing parenthesis and highlighted the matching opening parenthesis. Pressing Backspace again then removes both parentheses.</p>
<p>This intermediate state is called <em>restructuring mode</em>, and we picked up the closing parenthesis into the <em>backpack</em>; we will soon discuss these at greater length. For now, notice how restructuring mode served as a sort of confirmation dialog, showing us that removing the token on which we hit Backspace would require deleting other tokens. We believe such explicit confirmation is important to prevent “spooky action at a distance”, especially in light of the MPS user data discussed in the introduction. <!-- At the same time, the total number of keypresses (2) is
the same as would be required in a text editor. --></p>
<p>Now consider how we might re-insert the parentheses around the origin coordinates.</p>
<p><video src="mov/insert-paren.mov" width="350" controls=""><a href="mov/insert-paren.mov">Video</a></video></p>
<p>In a dual fashion to removal, inserting an opening parenthesis enters restructuring mode with its matching closing parenthesis in the backpack. Restructuring mode then allows us to move the parenthesis to the right and put it down. Notice the similarity to the text editing experience, which has an invoke-then-configure flow, whereas a typical structure editor would require you to select the body before parenthesizing, forcing preemptive configuration before invocation.</p>
<p>MPS supports a similar editing flow for parentheses in particular, but not any other syntactic forms also with matching delimiters. In contrast, as we will see next, <code>tylr</code> has well-defined restructuring behavior for arbitrary range selections.</p>
<h2 id="selecting-and-restructuring">Selecting and restructuring</h2>
<p>Using the arrow keys while holding Shift enters <code>tylr</code>’s <em>selecting mode</em>.</p>
<p><video src="mov/select.mov" width="350" controls=""><a href="mov/select.mov">Video</a></video></p>
<p>Selecting mode lets us specify arbitrary range selections up to token boundaries. Notice how, when a tile is divided by a selection boundary, it is disassembled into individual <em>shards</em>; then, once they are all within or without the selection, the shards are reassembled into the original tile. A selection containing no shards is called <em>intact</em>, otherwise <em>cracked</em>.</p>
<p>We may understand restructuring mode, not simply as a tile insertion and removal aid, but more generally as a structured variant of cut-and-paste on range selections, regulated by their intact versus cracked structure.</p>
<p><strong>Restructuring with a full backpack.</strong> In the previous section, we updated the circle drawing tracing the parabola <span class="math inline"><em>y</em> = <em>x</em><sup>2</sup>/9</span> to its reflection <span class="math inline"><em>x</em> = <em>y</em><sup>2</sup>/9</span> by deleting and re-inserting tiles. Alternatively, we could have selected those tiles—an impossible selection in a term-based editor—and used restructuring mode to move them.</p>
<p><video src="mov/restructure-full.mov" width="350" controls=""><a href="mov/restructure-full.mov">Video</a></video></p>
<p>We say that your backpack is <em>full</em> whenever its contents are, or could be assembled into, an intact selection. If your backpack is full, then you may move freely, since you may insert a selection of whole tiles anywhere without compromising the existing shard-balanced structure.</p>
<p>Often, however, your backpack’s contents are not an intact selection, nor can they be assembled into one, as we observed in the parentheses insertion and removal examples in the previous section. In that case, we say that your backpack is <em>hungry</em>…</p>
<p><strong>Restructuring with a hungry backpack.</strong> Now we would like the circles’ radii to grow with their origin coordinates. <img src="img/circles-parabola-grow-1.png" width="60" /> Accordingly we insert a let tile introducing variables <code>x</code> and <code>y</code> in the function body.</p>
<p><video src="mov/construct-let.mov" width="500" controls=""><a href="mov/construct-let.mov">Video</a></video></p>
<p>Our remaining task is to restructure our code so that <code>x</code> and <code>y</code> are bound to the origin coordinates <code>( n * n / 9 , n )</code> currently in the body of the let term. We select the <code>in</code> delimiter, disassembling the <code>let</code>-tile into a pair of shards; move right once; and put it down, upon which <code>tylr</code> reassembles the <code>let</code>-tile and returns us to pointing mode.</p>
<p><video src="mov/restructure-let.mov" width="500" controls=""><a href="mov/restructure-let.mov">Video</a></video></p>
<p>Notice that we skipped all cursor positions within the parentheses tile when we moved right. The <code>in</code>-shard in our backpack cannot be assembled into an intact selection on its own, meaning at least one matching shard—in this case, <code>let x , y =</code>—is anchored within the current tile sequence. This restricts our movement of the <code>in</code>-shard to cursor positions of the same sequence, as placing it in any other position would violate proper shard balancing.</p>
<p>We call the backpack full or hungry as a way to narrativize its control of our movement. When the backpack is full, it is satisfied and lets us move freely and leisurely through our code. When our backpack is hungry, it accelerates our movement through the current tile sequence in its impatience to end its hunger, which can happen in one of two ways. Either, like in the last example, we can empty the backpack, freeing it of all earthly possessions and desires; or we may feed it.</p>
<p><strong>Feeding a hungry backpack.</strong> Now we rewrite the radius in terms of the variables <code>x</code> and <code>y</code>.</p>
<p><video src="mov/grow-radius.mov" width="600" controls=""><a href="mov/grow-radius.mov">Video</a></video></p>
<p>Along the way, however, we forgot to parenthesize the origin coordinates. We also notice that the parentheses in the definition of the <code>let</code>-tile are now redundant and decide to recycle them. We move the cursor to the right parenthesis, select it, and pick it up into the backpack. At this point the backpack is hungry and restricts our movement to the tile sequence within the let definition.</p>
<p><video src="mov/multi-restructure-1.mov" width="600" controls=""><a href="mov/multi-restructure-1.mov">Video</a></video></p>
<p>Instead of emptying our backpack like in the last example, this time we move over to the left parenthesis and pick it up as well. At this point our backpack is full, as it carries both shards needed to assemble a parentheses tile, and we may move freely again.</p>
<p><video src="mov/multi-restructure-2.mov" width="600" controls=""><a href="mov/multi-restructure-2.mov">Video</a></video></p>
<p><strong>Picky eater.</strong> Not all selections can be picked up. We call the cursor positions marking the ends of a selection the selection’s <em>caps</em>. So far we have only encountered selections with caps of the same sort. Your backpack is a picky eater in the sense that it will refuse to carry any selections with caps of different sort.</p>
<p>Consider, for example, the following selection.</p>
<p><img src="img/diff-sort-cap.png" width="600" /></p>
<p>The left cap is pattern-sorted while the right cap is expression-sorted, as indicated by the two-toned broken overline. Picking up this selection would bring together tiles of different sort, so you are prevented from doing so.</p>
<h1 id="related-work">Related Work</h1>
<p>Structure editing has a long history, dating back to the introduction of the Cornell Program Synthesizer <span class="citation" data-cites="Cornell">[22]</span> in 1981. Here we focus our attention on contemporary editors.</p>
<p>The most popular structure editors today are block-based editors such as <a href="https://scratch.mit.edu/">Scratch</a>, <a href="https://snap.berkeley.edu/">Snap!</a>, <a href="http://appinventor.mit.edu/">App Inventor</a>, <a href="https://www.alice.org/">Alice</a>, and many more. In these editors, the user authors a program like the Scratch program shown below (adapted from <span class="citation" data-cites="blocks-csed">[28]</span>) by dragging-and-dropping blocks together on a canvas. Each block corresponds to a syntactic form of the underlying language and is shaped, based on its sort, to visually indicate how it should be placed relative to other blocks. <code>tylr</code> employs a similar metaphor of syntactic-forms-as-puzzle-pieces, but uses a uniform shape system across all sorts, thereby simplifying potential language extensions.</p>
<p><img src="img/scratch.png" width="200" /></p>
<p>Block-based editors have seen great success in recent years at introducing children to programming, but they soon become unwieldy once users start creating and maintaining larger or more expression-oriented programs. For example—adapting an observation by Brown et al. <span class="citation" data-cites="no-keyboard-cripples">[4]</span>—constructing the small calculation shown on the left involves assembling seven blocks, each requiring a sequence of gestures to find and drag-and-drop the appropriate block into the right spot in the canvas; the equivalent construction in a text editor or <code>tylr</code> would take seven keypresses.</p>
<p><img src="img/scratch-opseq.png" width="150" /></p>
<p>Meanwhile, in a user study of block-based editing involving large refactoring tasks, Holwerda and Hermans <span class="citation" data-cites="cog-dim-blocks">[9]</span> elicited post-task user responses on the cognitive dimensions of block-based editing and found that <em>viscosity</em> was the most commented-on dimension with 24 remarks. Half (12) were positive, a majority of which were about the ease of refactoring when the selected elements corresponded to complete syntactic terms. Of the negative half, half (6) were about the difficulty of refactoring when the desired selection does not correspond to a complete term; for example, in the first Scratch program shown above, dragging the <code>move</code> block out of the <code>repeat</code> block drags all the statements below along with it, thereby requiring multiple gestures in sum to select and remove the single <code>move</code> block. These results help motivate the expressive selection capabilities of tile-based editing.</p>
<p>The issue of restricted selection is not particular to block-based editors; any term-based editor fundamentally limits selections to complete terms. Recognizing these pitfalls, some structure editors <span class="citation" data-cites="Cornell greenfoot">[12, 22]</span> employ hybrid editing models, using structural editing for large syntactic forms while deferring to text editing at the leaves. This approach loses the benefits of structure editing at those levels, e.g., unrestricted language composition at the expression level. Moreover, while arbitrary text selections are possible within a text leaf, they cannot extend beyond those bounds and partially select any strictly structural forms.</p>
<p><a href="https://www.jetbrains.com/mps/">JetBrains MPS</a> <span class="citation" data-cites="DBLP:conf/icse/VoelterP12">[27]</span> aims to present a text-like interface while maintaining well-formedness at all times. It uses an array of techniques to support text-like editing flows, such as side tranforms to rearrange trees in operator sequences while constructing them linearly; and dangling parenthesis annotations in the edit state to support constructing parentheses individually <span class="citation" data-cites="GrammarCells">[24]</span>. Despite these techniques, as a term-based editor, MPS does not support directly selecting partial terms <span class="citation" data-cites="TowardUserFriendly">[26]</span>. For example, having typed <code>2 + 3 * 4</code> in MPS, it would not be possible to select <code>2 + 3</code> because this cuts across the parsed associative structure. Such restrictions are particularly surprising in an interface designed to look like text, as observed both in this example and our discussion of difficult-to-predict deletion in Section {#sec:Introduction}.</p>
<p>Term-based editors as a whole can be unexpectedly destructive when removing syntactic elements. For example, removing a block in a block-based editor removes all of its descendant blocks as well. MPS mitigates this by preserving the first child of a deleted term if they happen to share the same sort, but cannot preserve more than one child in a generic structure-preserving way. Owing to its more flexible tile structure—in particular, the convenient use of operator holes to concatenate multiple children—<code>tylr</code> can minimize removal by preserving all children of the same sort as the deleted tile.</p>
<p><a href="https://github.com/disconcision/fructure">Fructure</a> is a term-based editor for the Lisp family of programming languages. Similarly motivated to reduce the viscosity of structure editing, Fructure features a novel <em>transformation mode</em> by which the user may select a term and replace it with suggestions from an autocomplete menu. This menu supports interactive and arbitrarily deep construction of the replacement term before committing the replacement; meanwhile, at each step, the originally selected term is present in the list of suggestions, thereby supporting expressive wrapping of selections over the course of transformation. The user may also “paint” multiple terms before entering transformation mode, in which case the painted terms also appear in the menu suggestions. Fructure is strictly term-based and moreover restricted to S-expression syntax, which has no infix operator sequences.</p>
<h1 id="ongoing-work">Ongoing Work</h1>
<p><code>tylr</code> demonstrates novel structural selection and restructuring methods, but it is limited as a practical authoring tool in several respects. <code>tylr</code> edit states are visually rendered as a single line no matter their size. Construction is invoked with single keypresses (e.g., a <code>let</code>-tile is constructed using the <code>=</code> key) and number literals and variables are limited to single digits and characters. Moreover, <code>tylr</code>’s underlying language is tiny and features neither a type system nor an evaluation semantics.</p>
<p>We developed <code>tylr</code> with the intention of scaling up its editing techniques to Hazel <span class="citation" data-cites="HazelnutSNAPL">[21]</span>, a live programming environment featuring a structure editor with the usual multi-line text-like layout. Scaling up tile-based editing up to this setting poses additional design and engineering challenges, such as:</p>
<ul>
<li>dealing with textual input that maps to more than one tile shape (e.g., when you typed <code>-</code> did you intend negation or subtraction?);</li>
<li>visually summarizing large tiles and selections when restructuring;</li>
<li>integrating with pretty printed layout, often computationally expensive to produce;</li>
<li>animating layout transitions, which we suspect will become necessary to comprehend easily the effects of restructuring large program components.</li>
</ul>
<p>Hazel additionally maintains strong <em>semantic</em> guarantees: every edit state has a well-defined type and can be run to produce a well-defined result. The underlying expression language features, in addition to empty holes, non-empty holes that cordon off ill-typed portions of the program. Hazel is currently designed around a type-directed action semantics, which propagates contextual typing information down to the subject of its edit state so that it can insert and remove non-empty holes as needed to maintain well-formedness. We are currently working on decoupling Hazel’s typing concerns from the editing concerns so that we may cleanly extend tile-based editing with Hazel-style semantic invariants.</p>
<p>We implemented and ran a pilot user study on an early prototype of restructuring mode in July 2019, which suggested users quickly understood and appreciated the workflow in specific cases, but found the interface confusing given its ad hoc limitations. Now with a more principled and general design, we plan to run a controlled user study in which we compare the efficiency of and user sentiment toward text editing and tile-based editing in Hazel.</p>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-psg" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">Bahlke, R. and Snelting, G. 1992. Design and structure of a semantics-based programming environment. <em>International Journal of Man-Machine Studies</em>. 37, 4 (1992), 467–479. DOI:https://doi.org/<a href="https://doi.org/10.1016/0020-7373(92)90005-6">https://doi.org/10.1016/0020-7373(92)90005-6</a>.</div>
</div>
<div id="ref-blocks-and-beyond" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">Bau, D. et al. 2017. Learnable programming: Blocks and beyond. <em>Commun. ACM</em>. 60, 6 (May 2017), 72–80. DOI:https://doi.org/<a href="https://doi.org/10.1145/3015455">10.1145/3015455</a>.</div>
</div>
<div id="ref-ProjEfficiency" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">Berger, T. et al. 2016. Efficiency of projectional editing: A controlled experiment. <em>Proceedings of the 2016 24th ACM SIGSOFT international symposium on foundations of software engineering</em> (New York, NY, USA, 2016), 763–774.</div>
</div>
<div id="ref-no-keyboard-cripples" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">Brown, N.C.C. et al. 2015. Position paper: Lack of keyboard support cripples block-based programming. <em>2015 IEEE blocks and beyond workshop (blocks and beyond)</em> (2015), 59–61.</div>
</div>
<div id="ref-rousillon" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">Chasins, S.E. et al. 2018. Rousillon: Scraping distributed hierarchical web data. <em>Proceedings of the 31st annual ACM symposium on user interface software and technology</em> (New York, NY, USA, 2018), 963–975.</div>
</div>
<div id="ref-sns-pldi" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">Chugh, R. et al. 2016. Programmatic and <span>D</span>irect <span>M</span>anipulation, <span>T</span>ogether at <span>L</span>ast. <em>Conference on programming language design and implementation (PLDI)</em> (2016).</div>
</div>
<div id="ref-fine-tuning-selection-semantics" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">Goldenson, D.R. and Lewis, M.B. 1988. Fine tuning selection semantics in a structure editor based programming environment: Some experimental results. <em>SIGCHI Bull.</em> 20, 2 (Oct. 1988), 38–43. DOI:https://doi.org/<a href="https://doi.org/10.1145/54386.54400">10.1145/54386.54400</a>.</div>
</div>
<div id="ref-cog-dim" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">Green, T.R.G. and Petre, M. 1996. Usability analysis of visual programming environments: A <span>‘cognitive dimensions’</span> framework. <em>Journal of Visual Languages and Computing</em>. 7, 2 (1996), 131–174. DOI:https://doi.org/<a href="https://doi.org/10.1006/jvlc.1996.0009">https://doi.org/10.1006/jvlc.1996.0009</a>.</div>
</div>
<div id="ref-cog-dim-blocks" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">Holwerda, R. and Hermans, F. 2018. A usability analysis of blocks-based programming editors using cognitive dimensions. <em>2018 IEEE symposium on visual languages and human-centric computing (VL/HCC)</em> (2018), 217–225.</div>
</div>
<div id="ref-meta-analysis-blocks" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">Hu, Y. et al. 2021. Exploring the effectiveness and moderators of block-based visual programming on student learning: A meta-analysis. <em>Journal of Educational Computing Research</em>. 58, 8 (2021), 1467–1493. DOI:https://doi.org/<a href="https://doi.org/10.1177/0735633120945935">10.1177/0735633120945935</a>.</div>
</div>
<div id="ref-BasHermans21" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">Jansen, B. and Hermans, F. 2021. The effect of a block-based language on formula comprehension in spreadsheets. <em>2021 IEEE/ACM 29th international conference on program comprehension (ICPC)</em> (2021), 288–299.</div>
</div>
<div id="ref-greenfoot" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">Kölling, M. 2010. The greenfoot programming environment. <em>ACM Trans. Comput. Educ.</em> 10, 4 (Nov. 2010). DOI:https://doi.org/<a href="https://doi.org/10.1145/1868358.1868361">10.1145/1868358.1868361</a>.</div>
</div>
<div id="ref-lang-on-the-usefulness" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">Lang, B. 1986. On the usefulness of syntax directed editors. <em>Proceedings of an international workshop on advanced programming environments</em> (Berlin, Heidelberg, 1986), 47–51.</div>
</div>
<div id="ref-scratch" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">Maloney, J. et al. 2010. The scratch programming language and environment. <em>ACM Trans. Comput. Educ.</em> 10, 4 (Nov. 2010). DOI:https://doi.org/<a href="https://doi.org/10.1145/1868358.1868363">10.1145/1868358.1868363</a>.</div>
</div>
<div id="ref-MillerPMV94" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">Miller, P. et al. 1994. Evolution of novice programming environments: The structure editors of carnegie mellon university. <em>Interact. Learn. Environ.</em> 4, 2 (1994), 140–158. DOI:https://doi.org/<a href="https://doi.org/10.1080/1049482940040202">10.1080/1049482940040202</a>.</div>
</div>
<div id="ref-Minor92" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline">Minör, S. 1992. Interacting with structure-oriented editors. <em>Int. J. Man Mach. Stud.</em> 37, 4 (1992), 399–418. DOI:https://doi.org/<a href="https://doi.org/10.1016/0020-7373(92)90002-3">10.1016/0020-7373(92)90002-3</a>.</div>
</div>
<div id="ref-BlocksFingertips" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline">Monig, J. et al. 2015. Blocks at your fingertips: Blurring the line between blocks and text in GP. <em>Proceedings of the 2015 IEEE blocks and beyond workshop (blocks and beyond)</em> (Washington, DC, USA, 2015), 51–53.</div>
</div>
<div id="ref-user-modeling" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">Neal, L.R. 1986. Cognition-sensitive design and user modeling for syntax-directed editors. <em>SIGCHI Bull.</em> 18, 4 (May 1986), 99–102. DOI:https://doi.org/<a href="https://doi.org/10.1145/1165387.30866">10.1145/1165387.30866</a>.</div>
</div>
<div id="ref-Hazelnut" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">Omar, C. et al. 2017. Hazelnut: A bidirectionally typed structure editor calculus. <em>Proceedings of the 44th <span>ACM</span> <span>SIGPLAN</span> symposium on principles of programming languages, <span>POPL</span> 2017, paris, france, january 18-20, 2017</em> (2017), 86–99.</div>
</div>
<div id="ref-HazelnutLive" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">Omar, C. et al. 2019. Live functional programming with typed holes. <em><span>PACMPL</span></em>. 3, <span>POPL</span> (2019), 14:1–14:32. DOI:https://doi.org/<a href="https://doi.org/10.1145/3290327">10.1145/3290327</a>.</div>
</div>
<div id="ref-HazelnutSNAPL" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">Omar, C. et al. 2017. Toward semantic foundations for program editors. <em>Summit on advances in programming languages (SNAPL)</em> (2017).</div>
</div>
<div id="ref-Cornell" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">Teitelbaum, T. and Reps, T. 1981. The cornell program synthesizer: A syntax-directed programming environment. <em>Commun. ACM</em>. 24, 9 (Sep. 1981), 563–573. DOI:https://doi.org/<a href="https://doi.org/10.1145/358746.358755">10.1145/358746.358755</a>.</div>
</div>
<div id="ref-practical-lang-based-editing" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">Van De Vanter, M.L. 1995. Practical language-based editing for software engineers. <em>Software engineering and human-computer interaction</em> (Berlin, Heidelberg, 1995), 251–267.</div>
</div>
<div id="ref-GrammarCells" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">Voelter, M. et al. 2016. Efficient development of consistent projectional editors using grammar cells. <em>Proceedings of the 2016 ACM SIGPLAN international conference on software language engineering</em> (New York, NY, USA, 2016), 28–40.</div>
</div>
<div id="ref-mbeddr" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">Voelter, M. et al. 2019. Lessons learned from developing mbeddr: A case study in language engineering with MPS. <em>Softw. Syst. Model.</em> 18, 1 (Feb. 2019), 585–630. DOI:https://doi.org/<a href="https://doi.org/10.1007/s10270-016-0575-4">10.1007/s10270-016-0575-4</a>.</div>
</div>
<div id="ref-TowardUserFriendly" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[26] </div><div class="csl-right-inline">Voelter, M. et al. 2014. Towards user-friendly projectional editors. <em>Software language engineering</em> (Cham, 2014), 41–61.</div>
</div>
<div id="ref-DBLP:conf/icse/VoelterP12" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[27] </div><div class="csl-right-inline">Voelter, M. and Pech, V. 2012. Language modularity with the <span>MPS</span> language workbench. <em>34th international conference on software engineering, <span>ICSE</span> 2012, june 2-9, 2012, zurich, switzerland</em> (2012), 1449–1450.</div>
</div>
<div id="ref-blocks-csed" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[28] </div><div class="csl-right-inline">Weintrop, D. 2019. Block-based programming in computer science education. <em>Commun. ACM</em>. 62, 8 (Jul. 2019), 22–25. DOI:https://doi.org/<a href="https://doi.org/10.1145/3341221">10.1145/3341221</a>.</div>
</div>
<div id="ref-coblox" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[29] </div><div class="csl-right-inline">Weintrop, D. et al. 2018. Evaluating CoBlox: <span>A</span> comparative study of robotics programming environments for adult novices. <em>Proceedings of the 2018 <span>CHI</span> conference on human factors in computing systems, <span>CHI</span> 2018, montreal, QC, canada, april 21-26, 2018</em> (2018), 366.</div>
</div>
<div id="ref-blocks-text-high-school" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[30] </div><div class="csl-right-inline">Weintrop, D. and Wilensky, U. 2017. Comparing block-based and text-based programming in high school computer science classrooms. <em>ACM Trans. Comput. Educ.</em> 18, 1 (Oct. 2017). DOI:https://doi.org/<a href="https://doi.org/10.1145/3089799">10.1145/3089799</a>.</div>
</div>
<div id="ref-weitnauer2016graspable" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[31] </div><div class="csl-right-inline">Weitnauer, E. et al. 2016. Graspable math: Towards dynamic algebra notations that support learners better than paper. <em>2016 future technologies conference (FTC)</em> (2016), 406–414.</div>
</div>
</div>
</body>
</html>
