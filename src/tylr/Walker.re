module Path = {
  type t = {
    slope: Slope.Dn.t,
    last_kid: Meld.t,
  };
  let init = last_kid => {slope: Slope.empty, last_kid};
};

module Result = {
  type t = {
    eq: Mold.Map.t(list(Path.t)),
    lt: Mold.Map.t(list(Path.t)),
  };
  let empty = {eq: Mold.Map.empty, lt: Mold.Map.empty};
  let singleton = (m, path) => {lt: Mold.Map.empty, eq: Mold.Map.singleton(m, [path])};
  let union = (l, r) => {
    let u = Mold.Map.union((_, l, r) => Some(l@r));
    {eq: u(l.eq, r.eq), lt: u(l.lt, r.lt)};
  };
  let union_all = List.fold_left(union, empty);
  // todo maybe rename
  let newline = r => {
    eq: [],
    lt: union(r.lt, r.eq),
  };
};

let step = (m: Mold.t): Result.t => {
  // step to nearest mold
  let rec go = (z: GZipper.t(Atom.t)) => {
    let last_kid =
      switch (z) {
      | (Tok(_), _) => Meld.empty()
      | (Kid(s), _) => failwith("todo mk grout with s")
      };
    Regex.step(R, z.zipper)
    |> List.map(stop_or_go(~last_kid))
    |> Result.union_all;
  }
  and stop_or_go = (~last_kid, z: GZipper.t(Atom.t)) =>
    switch (z.zipper) {
    // stop
    | (Tok(lbl), ctx) =>
      let m = failwith("todo of lbl ctx sort prec");
      Result.singleton(m, Path.init(last_kid));
    // keep going
    | (Kid(s), _) =>
      let bound = Sort.eq(l.sort, s) ? bound : Prec.min;
      Grammar.enter(~from=L, ~bound, s)
      |> List.map(stop_or_go(~last_kid)) // lt steps
      |> List.map(Result.newline)
      |> List.cons(go(z)) // eq steps
      |> Result.union_all;
    };
  go(Mold.to_atom(m));
};












let union = Mold.Map.union((_, l, r) => Some(choose(~over?, l, r)));
let union_all = List.fold_left(union, Mold.Map.empty);

module Result = {
  type t('path) = {
    eq: list('path),
    lt: list('path),
  };
  let empty = {eq: [], lt: []};
  let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
  let concat = List.fold_left(cat, empty);
  let filter = f => TupleUtil.map2(List.filter(f));
};

// module Stepped = {
//   // eg stepping from ["("] e? ")" gives
//   // (
//   //   [{mel: empty, wal: ")"}, {mel: e_grout, wal: ")"}],
//   //   [{mel: e_grout, wal: "+"}, ...(and others generated by entering e)],
//   // )
//   type t = (list(Terrace.R.t), list(Terrace.R.t));
//   let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
//   let concat = List.fold_left(cat, ([], []));
//   let filter = f => TupleUtil.map2(List.filter(f));
// };

let step = (from: Wald.t, to_: Wald.t): Result.t(Terrace.R.t) => {
  let rec go = (z: GZipper.t(Atom.t)) =>
    z.zipper
    |> Regex.step(R)
    |> List.map(stop_or_go)
    |> Result.concat
  and stop_or_go = z =>
    switch (z.zipper) {
    // stop
    | (Tok(lbl), ctx) =>
      let m = failwith("todo of lbl ctx sort prec");
      Mold.eq(m, Wald.fst(to_).mold)
      ? {lt: [], eq: [Terrace.of_wald(to_)]}
      : Result.empty;
    // keep going
    | (Kid(s), _) =>
      let bound = Sort.eq(l.sort, s) ? bound : Prec.min;
      let stepped_lt =
        Grammar.enter(~from=L, ~bound, s)
        |> List.map(stop_or_go)
        |> Result.concat
        |> Result.newline;
      let g = failwith("todo mk grout meld for s");
      let stepped_eq =
        go(z)
        |> Result.map(Terrace.R.put_mel(g));
      Result.cat(stepped_eq, stepped_lt);
    };
  go(Mold.to_atom(Wald.lst(from).mold));
};

let walk = (from: Wald.t, to_: Wald.t): Result.t(Slope.Dn.t) => {
  let rec go = (~stepped_to=Mold.Set.empty, from: Wald.t) =>
    Mold.Set.mem(m, stepped_to)
    ? Result.empty
    : step(from, to_)
      |> Stepped.concat_map(to_ => {
        let n = Terrace.R.face(to_).mold;
        t
        |> walk_leq(~stepped_to=Mold.Set.add(n, stepped_to))
        |> Walked.complete(~from=to_)
      });

}




let step_leq = (t: Terrace.R.t): Result.t(Terrace.R.t) => {
  let rec step = (~lt=false, z: GZipper.t(Atom.t)) => {
    let last_kid =
      switch (z) {
      | (Tok(_), _) => Meld.empty()
      | (Kid(s), _) => failwith("todo mk grout with s")
      };
    Regex.step(R, z.zipper)
    |> List.map(stop_or_step(~lt, ~last_kid))
    |> Stepped.concat;
  }
  and stop_or_step = (~lt, ~last_kid, z: GZipper.t(Atom.t)) =>
    switch (z.zipper) {
    | (Kid(s), _) =>
      let bound = Sort.eq(l.sort, s) ? bound : Prec.min;
      Grammar.enter(~from=L, ~bound, s)
      |> List.map(stop_or_step(~lt=true, ~last_kid))
      |> Stepped.concat
      |> Stepped.cat(step(~lt, z));
    | (Tok(lbl), ctx) =>
      let m = failwith("todo of lbl ctx sort prec");
      let p = failwith("todo using m");
      let ts = [Terrace.{mel: last_kid, wal: Wald.of_piece(p)}];
      lt ? ([], ts) : (ts, []);
    };
  Terrace.face(t).mold
  |> Mold.to_atom
  |> step;
};
// todo: maybe incorporate kid sort to sort results
// todo: probably need to pass in space
let leq = (l: Terrace.R.t, r: Mold.t): list(Slope.Dn.t) =>
  step_leq(l)
  |> Stepped.to_mold(r)
  |> Stepped.complete(~from=l);

let rec walk_leq = (~stepped_to=Mold.Set.empty, from: Terrace.R.t): Result.t(Slope.Dn.t) => {
  Mold.Set.mem(m, stepped_to)
  ? Walked.empty
  : step_leq(from)
    |> Stepped.concat_map(to_ => {
      let n = Terrace.R.face(to_).mold;
      t
      |> walk_leq(~stepped_to=Mold.Set.add(n, stepped_to))
      |> Walked.complete(~from=to_)
    });
};
// todo: maybe incorporate kid sort to sort results
let leq_trans = (l: Terrace.R.t, r: Mold.t): list(Slope.Dn.t) =>
  walk_leq(l)
  |> Walked.to_mold(r)
  |> Walked.complete(~from=l);
