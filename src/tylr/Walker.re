let union = Mold.Map.union((_, l, r) => Some(choose(~over?, l, r)));
let union_all = List.fold_left(union, Mold.Map.empty);

module Result = {
  type t('path) = {
    eq: list('path),
    lt: list('path),
  };
  let empty = {eq: [], lt: []};
  let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
  let concat = List.fold_left(cat, empty);
  let filter = f => TupleUtil.map2(List.filter(f));
};

// module Stepped = {
//   // eg stepping from ["("] e? ")" gives
//   // (
//   //   [{mel: empty, wal: ")"}, {mel: e_grout, wal: ")"}],
//   //   [{mel: e_grout, wal: "+"}, ...(and others generated by entering e)],
//   // )
//   type t = (list(Terrace.R.t), list(Terrace.R.t));
//   let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
//   let concat = List.fold_left(cat, ([], []));
//   let filter = f => TupleUtil.map2(List.filter(f));
// };

let step = (p: Piece.t): Result.t(Terrace.R.t) => {
  let rec go = (z: GZipper.t(Atom.t)) =>
    z.zipper |> Regex.step(R) |> List.map(stop_or_go) |> Result.concat
  and stop_or_go = z =>
    switch (z.zipper) {
    // stop
    | (Tok(lbl), ctx) =>
      let m = failwith("todo mold of lbl ctx sort prec");
      let p = failwith("todo piece of m");
      {lt: [], eq: [Terrace.of_piece(p)]};
    // keep going
    | (Kid(s), _) =>
      let bound = Sort.eq(l.sort, s) ? bound : Prec.min;
      let stepped_lt =
        Grammar.enter(~from=L, ~bound, s)
        |> List.map(stop_or_go)
        |> Result.concat
        |> Result.newline;
      let g = failwith("todo mk grout meld for s");
      let stepped_eq = go(z) |> Result.map(Terrace.R.put_mel(g));
      Result.cat(stepped_eq, stepped_lt);
    };
  go(Mold.to_atom(p.mold));
};

let walk = (from: Wald.t): Result.t(Slope.Dn.t) => {
  let rec go = (~stepped_to=Mold.Set.empty, p: Piece.t) =>
    Mold.Set.mem(p.mold, stepped_to)
      ? Result.empty
      : step(from)
        |> Result.concat_map(to_ => {
             let q = Terrace.R.face(to_);
             q
             |> go(~stepped_to=Mold.Set.add(q.mold, stepped_to))
             |> Result.complete(~from=to_);
           });
  go(Terrace.R.face(from));
};
