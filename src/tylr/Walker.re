// walk criteria
// - overall length
// - height
// - if there's a middle kid, whether there's a slot that accommodates

module Mold = {
  [@deriving (sexp, ord)]
  type t = Gram.Zipper.t(Label.t);
  module Ord = {
    type nonrec t = t;
    let compare = compare;
  };
  module Map = Map.Make(Ord);
  module Set = Set.Make(Ord);

  // mold imposes bound on neighbors
  let bound: (Dir.t, t) => Prec.Bound.t = failwith("todo");
};

// module Slot = {
//   type t = Gram.Zipper.t(Regex.t);

//   let empty = (~sort, ~prec) => Gram.Zipper.{sort, prec, zipper: (Regex.empty, Regex.Ctx.empty)};

//   // slot is bounded by neighboring molds
//   // let bound: (Dir.t, t) => option(Prec.Bound.t) = failwith("todo");
// };

// module Piece = {
//   // todo rename
//   type t =
//     | Grout
//     | Tile(Mold.t);
// };

module Mold = {
  // thinking this is the proper mold type
  // clearly indicates and enforces:
  // - mold-space is divided into tile molds and grout molds
  // - tile molds are grammar zippers focused on whatever label is specified
  //   in that context by the grammar
  // - grout molds describe "holes" in the grammar, hence nothing of focus
  type t =
    | Grout(Gram.Zipper.t(unit))
    | Tile(Gram.Zipper.t(Label.t));
};

let union = Mold.Map.union((_, l, r) => Some(choose(~over?, l, r)));
let union_all = List.fold_left(union, Mold.Map.empty);

module Result = {
  type t = {
    eq: list(Slope.t),
    lt: list(Slope.t),
  };
  let empty = {eq: [], lt: []};
  let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
  let concat = List.fold_left(cat, empty);
  let filter = f => TupleUtil.map2(List.filter(f));
  let concat_map: (Slope.t => list(Slope.t), t) => t = failwith("todo");
  let complete: (~from: Terrace.R.t, t) => list(Slope.t) = failwith("todo");

  // intended functionality here is
  // 1. to filter slopes based on destination
  //    and replace final dummy piece with actual wald
  // 2. pick best sort given kid
  //    a. prioritize those that have the exact sort (accommodate existing kid, no backtracking)
  //    b. then based on size (least correction)
  // 3. stick on terr at the front depending on lt/eq slope
  let pick:
    (~from: Terrace.R.t, ~over: Meld.t, ~to_: Wald.t, t) => option(Slope.t) =
    failwith("todo");
};

// module Stepped = {
//   // eg stepping from ["("] e? ")" gives
//   // (
//   //   [{mel: empty, wal: ")"}, {mel: e_grout, wal: ")"}],
//   //   [{mel: e_grout, wal: "+"}, ...(and others generated by entering e)],
//   // )
//   type t = (list(Terrace.R.t), list(Terrace.R.t));
//   let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
//   let concat = List.fold_left(cat, ([], []));
//   let filter = f => TupleUtil.map2(List.filter(f));
// };

// slightly awkward that input is "static" while output is "dynamic",
// but need static input for memoization, dynamic output without
// creating another datatype
let step = (m: Mold.t): Result.t => {
  let rec go = (z: Gram.Zipper.t(Atom.t)) =>
    z.zipper |> Regex.step(R) |> List.map(stop_or_go) |> Result.concat
  and stop_or_go = z =>
    switch (z.zipper) {
    // stop
    | (Tok(lbl), ctx) =>
      let m = failwith("todo mold of lbl ctx sort prec");
      let p = failwith("todo piece of m");
      {lt: [], eq: [Terrace.of_piece(p)]};
    // keep going
    | (Kid(s), _) =>
      let bound = Sort.eq(l.sort, s) ? bound : Prec.min;
      let stepped_lt =
        Gram.enter(~from=L, ~bound, s)
        |> List.map(stop_or_go)
        |> Result.concat
        |> Result.newline;
      let g = failwith("todo mk grout meld for s");
      let stepped_eq = go(z) |> Result.map(Terrace.R.put_mel(g));
      Result.cat(stepped_eq, stepped_lt);
    };
  go(Mold.to_atom(m));
};

let walk = (from: Mold.t): Result.t => {
  let rec go = (~stepped_to=Mold.Set.empty, m: Mold.t) =>
    Mold.Set.mem(m, stepped_to)
      ? Result.empty
      : step(from)
        |> Result.concat_map(to_ => {
             let n = Terrace.R.face(to_);
             n
             |> go(~stepped_to=Mold.Set.add(n, stepped_to))
             |> Result.complete(~from=to_);
           });
  go(from);
};
