// walk criteria
// - overall length
// - height
// - if there's a middle kid, whether there's a slot that accommodates

module GZipper = {
  // a zipper into a Grammar.t
  type t('subj) = {
    sort: Sort.t,
    prec: Prec.t,
    zipper: Regex.Zipper.t('subj),
  };

  let map = failwith("todo");
  let map_opt = failwith("todo");
};

module Mold = {
  [@deriving (sexp, ord)]
  type t = GZipper.t(Label.t);
  module Ord = {
    type nonrec t = t;
    let compare = compare;
  };
  module Map = Map.Make(Ord);
  module Set = Set.Make(Ord);

  // mold imposes bound on neighbors
  let bound: (Dir.t, t) => Prec.Bound.t = failwith("todo");
};

// module Slot = {
//   type t = GZipper.t(Regex.t);

//   let empty = (~sort, ~prec) => GZipper.{sort, prec, zipper: (Regex.empty, Regex.Ctx.empty)};

//   // slot is bounded by neighboring molds
//   // let bound: (Dir.t, t) => option(Prec.Bound.t) = failwith("todo");
// };

module Piece = {
  // todo rename
  type t =
    | Grout
    | Tile(Mold.t);
};

// module Walk = {
//   type t = Chain.t(Slot.t, Piece.t);
// };

module Result = {
  include Result;
  type t = Result.t(Slope.Dn.t, Meld.t);

  let merge = (l, r) =>
    switch (l, r) {
    | (Error(_), _) => r
    | (_, Error(_)) => l
    | (Ok(s_l), Ok(s_r)) => Slope.Dn.compare(s_l, s_r) <= 0 ? l : r
    };

  let merge_all = err => List.fold_left(merge, Error(err));
};

let union = Mold.Map.union((_, l, r) => Some(choose(~over?, l, r)));
let union_all = List.fold_left(union, Mold.Map.empty);

let is_operator = (operand_side: Dir.t, r: Regex.t) =>
  Regex.enter(~from=operand_side, r)
  |> List.exists(((a, _)) => Regex.Atom.is_kid(a));

module Moved = {
  type t('path) = {
    eq: list('path),
    lt: list('path),
  };
  let empty = {eq: [], lt: []};
  let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
  let concat = List.fold_left(cat, ([], []));
  let filter = f => TupleUtil.map2(List.filter(f));
};

module Stepped = {
  include Moved;
  type t = Moved.t(Terrace.R.t);
};

module Walked = {
  include Moved;
  type t = Moved.t(Slope.Dn.t);
}

// module Stepped = {
//   // eg stepping from ["("] e? ")" gives
//   // (
//   //   [{mel: empty, wal: ")"}, {mel: e_grout, wal: ")"}],
//   //   [{mel: e_grout, wal: "+"}, ...(and others generated by entering e)],
//   // )
//   type t = (list(Terrace.R.t), list(Terrace.R.t));
//   let cat = ((eq, lt), (eq', lt')) => (eq @ eq', lt @ lt');
//   let concat = List.fold_left(cat, ([], []));
//   let filter = f => TupleUtil.map2(List.filter(f));
// };

let step_leq = (t: Terrace.R.t): Stepped.t => {
  let rec step = (~lt=false, z: GZipper.t(Atom.t)) => {
    let last_kid =
      switch (z) {
      | (Tok(_), _) => Meld.empty()
      | (Kid(s), _) => failwith("todo mk grout with s")
      };
    Regex.step(R, z.zipper)
    |> List.map(stop_or_step(~lt, ~last_kid))
    |> Stepped.concat;
  }
  and stop_or_step = (~lt, ~last_kid, z: GZipper.t(Atom.t)) =>
    switch (z.zipper) {
    | (Kid(s), _) =>
      let bound = Sort.eq(l.sort, s) ? bound : Prec.min;
      Grammar.enter(~from=L, ~bound, s)
      |> List.map(stop_or_step(~lt=true, ~last_kid))
      |> Stepped.concat
      |> Stepped.cat(step(~lt, z));
    | (Tok(lbl), ctx) =>
      let m = failwith("todo of lbl ctx sort prec");
      let p = failwith("todo using m");
      let ts = [Terrace.{mel: last_kid, wal: Wald.of_piece(p)}];
      lt ? ([], ts) : (ts, []);
    };
  Terrace.face(t).mold
  |> Mold.to_atom
  |> step;
};
// todo: maybe incorporate kid sort to sort results
// todo: probably need to pass in space
let leq = (l: Terrace.R.t, r: Mold.t): list(Slope.Dn.t) =>
  step_leq(l)
  |> Stepped.to_mold(r)
  |> Stepped.complete(~from=l);

let rec walk_leq = (~stepped_to=Mold.Set.empty, from: Terrace.R.t): Walked.t => {
  Mold.Set.mem(m, stepped_to)
  ? Walked.empty
  : step_leq(from)
    |> Stepped.concat_map(to_ => {
      let n = Terrace.R.face(to_).mold;
      t
      |> walk_leq(~stepped_to=Mold.Set.add(n, stepped_to))
      |> Walked.complete(~from=to_)
    });
};
// todo: maybe incorporate kid sort to sort results
let leq_trans = (l: Terrace.R.t, r: Mold.t): list(Slope.Dn.t) =>
  walk_leq(l)
  |> Walked.to_mold(r)
  |> Walked.complete(~from=l);

// wrap terrace around kid and complement as needed
let wrap = (_terr, _kid) => failwith("todo");

module Terrace = {
  let mold = (terr: Terrace.R.t, ~kid=Meld.empty(), t: Token.t): Result.t =>
    Molds.of_token(t)
    |> Result.merge_all(wrap(terr, kid))
}

module Slope = {
  let rec mold = (slope: Slope.Dn.t, ~kid=Meld.empty(), t: Token.t): Result.t =>
    switch (slope.terrs) {
    | [] => Error(kid)
    | [terr, ...terrs] =>
      // todo: push slope space onto kid
      let tl_molded = mold({...slope, terrs}, ~kid=wrap(terr, kid), t);
      switch (Terrace.mold(terr, ~kid, t)) {
      | Error(_) => tl_molded
      | Ok(hd) =>
        switch (tl_molded) {
        | Ok(tl) when Slope.Dn.compare(hd, tl) > 0 => tl_molded
        | _ => Ok(Slope.Dn.cat(Slope.mk(terrs), hd))
        }
      };
    };
}